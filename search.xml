<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode486</title>
    <url>/2020/09/01/LeetCode486/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/predict-the-winner/">预判赢家</a><br><img src="/2020/09/01/LeetCode486/%E9%A2%98%E7%9B%AE.png" alt="题目"></p>
<a id="more"></a>
<p>就这种博弈小游戏来说，我们很容易得知先手玩家存在优势，因为尽管后手玩家在第二回合可以选择最优策略，但先手玩家可以另这个最优策略最差。<br>即，先手玩家可以决定后手玩家接下来要面对的局面。<br>回到本题，对于先手玩家来说，队首或队尾数字这两个选择中，必然存在一个最优解，而在第二回合，后手玩家也会选择最优解，接着第三回合…. 可以发现，游戏结局从一开始就已经<strong>唯一确定</strong>了.<br>所以我们只需要按照以上逻辑，求得各个回合，玩家选择最优解后的得分即可求解此题<br>观察上述逻辑结构，容易发现使用<strong>递归</strong>最容易模拟…<br><img src="/2020/09/01/LeetCode486/%E6%8F%90%E7%A4%BA.png" alt="题目提示"></p>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, score;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        score = dfs(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(score * <span class="number">2</span> &gt;= sum) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 根据提示可知，二者分数相同，先手玩家获胜</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> flag)</span> </span>&#123; <span class="comment">// flag记录先手玩家的回合</span></span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r &amp;&amp; flag) <span class="keyword">return</span> nums[l];</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r &amp;&amp; !flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> max(nums[l] + dfs(nums, l + <span class="number">1</span>, r, !flag), nums[r] + dfs(nums, l, r - <span class="number">1</span>, !flag));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(dfs(nums, l + <span class="number">1</span>, r, !flag), dfs(nums, l, r - <span class="number">1</span>, !flag)); <span class="comment">// 因为二者分数的总和不变，所以一个玩家的最优解即是另一个玩家的最差解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">22</span>][<span class="number">22</span>]; <span class="comment">// 记录每次搜索的结果，避免多次计算同一状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, score;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) sum += i;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        score = dfs(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(score * <span class="number">2</span> &gt;= sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r &amp;&amp; flag) <span class="keyword">return</span> nums[l];</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r &amp;&amp; !flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[l][r] != <span class="number">0</span>) <span class="keyword">return</span> vis[l][r];</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> vis[l][r] =  max(nums[l] + dfs(nums, l + <span class="number">1</span>, r, !flag), nums[r] + dfs(nums, l, r - <span class="number">1</span>, !flag));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> vis[l][r] = min(dfs(nums, l + <span class="number">1</span>, r, !flag), dfs(nums, l, r - <span class="number">1</span>, !flag));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h1><p>待补</p>
]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>DP</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode1</title>
    <url>/2020/09/01/LeetCode1/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a><br><img src="/2020/09/01/LeetCode1/%E9%A2%98%E7%9B%AE.png" alt="题目"></p>
<a id="more"></a>
<h1 id="题解s"><a href="#题解s" class="headerlink" title="题解s"></a>题解s</h1><pre><code>用map记录每个target-nums[i]，如果之后的nums[i]在map里出现过，记录并返回二者坐标。</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.find(nums[i]) != mp.end()) &#123;</span><br><span class="line">                a = i;</span><br><span class="line">                b = mp[nums[i]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[target - nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/08/22/test/</url>
    <content><![CDATA[<p>这是一个测试！！！</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">                           _ooOoo_</span></span><br><span class="line"><span class="comment">                          o8888888o</span></span><br><span class="line"><span class="comment">                          88&quot; . &quot;88</span></span><br><span class="line"><span class="comment">                          (| -_- |)</span></span><br><span class="line"><span class="comment">                          O\  =  /O</span></span><br><span class="line"><span class="comment">                       ____/`---&#x27;\____</span></span><br><span class="line"><span class="comment">                     .&#x27;  \\|     |//  `.</span></span><br><span class="line"><span class="comment">                    /  \\|||  :  |||//  \</span></span><br><span class="line"><span class="comment">                   /  _||||| -:- |||||-  \</span></span><br><span class="line"><span class="comment">                   |   | \\\  -  /// |   |</span></span><br><span class="line"><span class="comment">                   | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |</span></span><br><span class="line"><span class="comment">                   \  .-\__  `-`  ___/-. /</span></span><br><span class="line"><span class="comment">                 ___`. .&#x27;  /--.--\  `. . __</span></span><br><span class="line"><span class="comment">              .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.</span></span><br><span class="line"><span class="comment">             | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span></span><br><span class="line"><span class="comment">             \  \ `-.   \_ __\ /__ _/   .-` /  /</span></span><br><span class="line"><span class="comment">        ======`-.____`-.___\_____/___.-`____.-&#x27;======</span></span><br><span class="line"><span class="comment">                           `=---=&#x27;</span></span><br><span class="line"><span class="comment">        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"><span class="comment">                 佛祖保佑       永无BUG</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">&#125;e[<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m,p[<span class="number">2020</span>],q[<span class="number">20010</span>];</span><br><span class="line"><span class="keyword">int</span> vi[<span class="number">1010</span>],ne;</span><br><span class="line"><span class="keyword">int</span> vc[<span class="number">1010</span>],gr[<span class="number">1010</span>],G[<span class="number">1010</span>][<span class="number">1010</span>],gf[<span class="number">1010</span>],fa[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> du[<span class="number">1010</span>],d[<span class="number">1010</span>],c[<span class="number">10010</span>],base[<span class="number">1010</span>],now,fi,head,wei;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(gr,<span class="number">0</span>,<span class="keyword">sizeof</span> gr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        u=base[u];</span><br><span class="line">        gr[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!vi[u]) <span class="keyword">break</span>;</span><br><span class="line">        u=fa[vi[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        v=base[v];</span><br><span class="line">        <span class="keyword">if</span> (gr[v]) <span class="keyword">break</span>;</span><br><span class="line">        v=fa[vi[v]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u!=ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=vi[u];</span><br><span class="line">        gf[base[v]]=gf[base[u]]=<span class="number">1</span>;</span><br><span class="line">        u=fa[v];</span><br><span class="line">        <span class="keyword">if</span> (base[u]!=ne) fa[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne=lca(u,v);</span><br><span class="line">    <span class="built_in">memset</span>(gf,<span class="number">0</span>,<span class="keyword">sizeof</span> gf);</span><br><span class="line">    init(u);init(v);</span><br><span class="line">    <span class="keyword">if</span> (base[u]!=ne) fa[u]=v;</span><br><span class="line">    <span class="keyword">if</span> (base[v]!=ne) fa[v]=u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">     <span class="keyword">if</span> (gf[base[i]])&#123;</span><br><span class="line">            base[i]=ne;</span><br><span class="line">            <span class="keyword">if</span> (!vc[i]) c[++wei]=i,vc[i]=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vc,<span class="number">0</span>,<span class="keyword">sizeof</span> vc);</span><br><span class="line">    <span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="keyword">sizeof</span> fa);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) base[i]=i;</span><br><span class="line">    head=<span class="number">1</span>;wei=<span class="number">1</span>;c[<span class="number">1</span>]=now;vc[now]=<span class="number">1</span>;</span><br><span class="line">    fi=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head&lt;=wei)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=c[head++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">         <span class="keyword">if</span> (G[u][v]&amp;&amp;base[u]!=base[v]&amp;&amp;vi[v]!=u)&#123;</span><br><span class="line">                <span class="keyword">if</span> (v==now||(vi[v]&gt;<span class="number">0</span>)&amp;&amp;(fa[vi[v]]&gt;<span class="number">0</span>))&#123;</span><br><span class="line">                    f1(u,v);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (fa[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                    fa[v]=u;</span><br><span class="line">                    <span class="keyword">if</span> (vi[v])&#123;</span><br><span class="line">                        c[++wei]=vi[v];vc[vi[v]]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        fi=v;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    u=fi;</span><br><span class="line">    <span class="keyword">while</span> (u&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        v=fa[u];</span><br><span class="line">        w=vi[v];</span><br><span class="line">        vi[u]=v;</span><br><span class="line">        vi[v]=u;</span><br><span class="line">        u=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vi,<span class="number">0</span>,<span class="keyword">sizeof</span> vi);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">if</span> (!vi[i])&#123;</span><br><span class="line">        now=i;</span><br><span class="line">        f2();</span><br><span class="line">        <span class="keyword">if</span> (fi) f3(),res++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">if</span> (!vi[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(G,<span class="number">0</span>,<span class="keyword">sizeof</span> G);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">if</span> (du[i]&gt;d[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span> p); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p[e[i].u])</span><br><span class="line">        &#123;</span><br><span class="line">            p[e[i].u]=++cnt;</span><br><span class="line">            q[e[i].u]=cnt+d[e[i].u]-du[e[i].u]<span class="number">-1</span>;</span><br><span class="line">            cnt=cnt+d[e[i].u]-du[e[i].u]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!p[e[i].v])</span><br><span class="line">        &#123;</span><br><span class="line">            p[e[i].v]=++cnt;</span><br><span class="line">            q[e[i].v]=cnt+d[e[i].v]-du[e[i].v]<span class="number">-1</span>;</span><br><span class="line">            cnt=cnt+d[e[i].v]-du[e[i].v]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=cnt+<span class="number">2</span>;cnt+=<span class="number">2</span>;</span><br><span class="line">        G[k][k<span class="number">-1</span>]=G[k<span class="number">-1</span>][k]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=p[e[i].u];j&lt;=q[e[i].u];j++) G[j][k<span class="number">-1</span>]=G[k<span class="number">-1</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=p[e[i].v];j&lt;=q[e[i].v];j++) G[j][k]=G[k][j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n=cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span> &gt;&gt; du[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i].u;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i].v;</span><br><span class="line">            d[e[i].u]++;d[e[i].v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(build()&amp;&amp;solve())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode17电话号码的字母组合</title>
    <url>/2020/08/27/LeetCode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">题目链接</a><br>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<a id="more"></a>
<p><img src="/2020/08/27/LeetCode17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/images.png"><br>示例：<br>    输入：”23”<br>    输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>思路：<br>    题意十分简单,我们只需要输出一串数字对应的所有字母组合就行,又因数据范围很小,所以我们可以直接采用DFS/BFS暴力跑一遍即可.<br>    这里简单说一下回溯的方式,可以用str.pop_back();退回到上一个状态.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; mp = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;, &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>&#125;, &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>&#125;, &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>&#125;, &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>&#125;, &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>&#125;, &#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&quot;tuv&quot;</span>&#125;, &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">            <span class="keyword">if</span>(digits != <span class="string">&quot;&quot;</span>) dfs(digits, ans, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> digits, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="built_in">string</span>::size_type pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">if</span> (pos == digits.size()) &#123;</span><br><span class="line">            ans.push_back(word);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : mp[digits[pos]]) &#123;</span><br><span class="line">                word += i;</span><br><span class="line">                dfs(digits, ans, pos + <span class="number">1</span>);</span><br><span class="line">                word.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode529扫雷游戏</title>
    <url>/2020/08/23/LeetCode529%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minesweeper/">题目链接</a><br>DFS或BFS按照题意搜一遍即可，需要注意的是按照游戏规则应该往8个方向进行搜索。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; <span class="title">updateBoard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(board, click[<span class="number">0</span>], click[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> xx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> yy = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(xx &lt; <span class="number">0</span> || xx &gt;= board.size() || yy &lt; <span class="number">0</span> || yy &gt;= board[<span class="number">0</span>].size()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[xx][yy] == <span class="string">&#x27;M&#x27;</span>) cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            board[x][y] = cnt + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)&#123;</span><br><span class="line">                <span class="keyword">int</span> xx = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> yy = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(xx &lt; <span class="number">0</span> || xx &gt;= board.size() || yy &lt; <span class="number">0</span> || yy &gt;= board[<span class="number">0</span>].size()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[xx][yy] == <span class="string">&#x27;E&#x27;</span>) dfs(board ,xx, yy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode201数字范围按位与</title>
    <url>/2020/08/27/LeetCode201%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/">题目链接</a><br>题意:<br>    给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h1><pre><code>输入: 5 7
输出: 4</code></pre>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h1><pre><code>输入: 0 1
输出: 0</code></pre>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h1><p>数据范围很大,直接暴力跑起来肯定超时.<br>于是,从按位与的相关特性入手,即对应二进制位全是1则为1,否则为0;<br>那n到m的所有数里,对应二进制位上只要有一个为0,则最终结果该二进制位上也为0;<br>而我们又知道,加法只影响<strong>连续的低位</strong>,所以根据按位与的特性,某个位置一旦受到影响则该位置的最终结果一定为0;<br>所以很显然,我们只需要求得没有被影响的<strong>连续高位</strong>,再将后续所有二进制位赋0,即可求得结果.<br>很显然,没有被影响到的连续高位即是n和m<strong>二进制串的最长公共前缀</strong>.<br><img src="/2020/08/27/LeetCode201%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/1.png" alt="如图所示,我们可以很清晰的看到在从n加到m的过程中,哪些二进制位被影响了"><br>这时,我们可以用Brian Kernighan算法帮助我们求得结果,即n&amp;(n−1)的结果是n的二进制位最右端的1变为0的结果.<br>这样我们可以对m进行m&amp;(m-1)直到m &lt;= n,此时被影响到的二进制位上的1已经被清除了,再计算n&amp;m即可求得二者的<strong>二进制串的最长公共前缀</strong>,也就是我们想要的结果.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> solve(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; n)&#123;</span><br><span class="line">            m = m &amp; (m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &amp; m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode每日一题</category>
      </categories>
      <tags>
        <tag>MATH</tag>
      </tags>
  </entry>
</search>
